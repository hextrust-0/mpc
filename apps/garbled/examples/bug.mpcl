// -*- go -*-

package main

type Garbler struct {
	msg       [64]byte
	privShare [64]byte
}

func main(g Garbler, privShare [64]byte) ([]byte, uint) {
	var priv [64]byte

	// Offending command follows
	if true {
		for i := 0; i < len(priv); i++ {
			priv[i] = g.privShare[i] ^ privShare[i]
		}
	}
	// Offending command precedes

	sig, ui := Sign(g.msg)
	return sig, ui
}

func Sign(message []byte) ([]byte, uint) {
	buf2 := make([]byte, 64+len(message))
	return Sum512(buf2)
}

const (
	// The size of a SHA512 checksum in bytes.
	Size = 64

	// BlockSize is the block size, in bytes, of the SHA-512/224,
	// SHA-512/256, SHA-384 and SHA-512 hash functions.
	BlockSize = 128

	init = 0x6a09e667f3bcc908bb67ae8584caa73b3c6ef372fe94f82ba54ff53a5f1d36f1510e527fade682d19b05688c2b3e6c1f1f83d9abfb41bd6b5be0cd19137e2179
)

func Sum512(data []byte) ([]byte, uint) {
	var state uint512 = init
	var block uint1024
	var hash [Size]byte

	var pad [BlockSize]byte
	pad[0] = 0x80

	for i := 0; i < len(data); i++ {
		block <<= 8
		block = block | uint1024(data[i])

		if (i+1)%BlockSize == 0 {
			//state = Block(block, state)
			block = uint1024(0)
		}
	}
	// XXX here hash and block are both 0 in both cases
	if len(data)%BlockSize < 112 {
		for i := len(data) % BlockSize; i < 112; i++ {
			block <<= 8
			block |= uint1024(pad[i-len(data)%BlockSize])
		}
	} else {
		for i := len(data) % BlockSize; i < BlockSize; i++ {
			block <<= 8
			block |= uint1024(pad[i-len(data)%BlockSize])
		}
		// state = Block(block, state)
		block = uint1024(0)
	}
	// XXX here block differs between cases
	// Length in bits.
	block <<= 128 // broken with const folding

	// XXX here block differs 0 vs. number
	return hash, block
}
